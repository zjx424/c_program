/*冒泡排序：
3，7，4，2，6，1，选择第0，和第1个，对比，大的放在后面
6个数字需要比较的是，【0，1】 【1，2】 【2，3】 【3，4】 【4，5】
只需要进行 n-1次比较 n为数字的个数
选择第1个和第2个，对比，大的放后面，每次进行全组数据的对比，就可以把最大值，放到最后面
然后使用除最后那个最大值之外的数字，实现同样的方法，即可以实现排序
*/
/*冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。
所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，
那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，
所以冒泡排序是一种稳定排序算法。*/
#include <stdio.h>
//n是个数
//函数有时候不需要定义？
void bubble(int arr[],int n);
void bubbleSort(int arr[],int n);

void bubble(int arr[],int n)
{
	int temp;
	for (int i = 0; i < n-1; ++i)
	{
		if (arr[i]>arr[i+1])//从小到大，还是从大到小，只需要改变这里的符号
		{
			//交换的经典算法
			temp=arr[i+1];
			arr[i+1]=arr[i];
			arr[i]=temp;
		}
	}
}

void bubbleSort(int arr[],int n)
{
	//教程有误，i不是>=1
	//假设有两个数进行冒泡排序，依照i>=1的算法的话，则需要排序两次，实则只需要一次
	//所以这里是>即可
	for (int i = n; i >1 ; i--)
	{
		bubble(arr,i);
	}
}

int main(int argc, char const *argv[])
{
	int arr[]={4,7,2,1,8,5,6,9,3,10,12,13,11};
	int n=13;
	bubbleSort(arr,n);
	for (int i = 0; i < 13; ++i)
	{
		printf("%d\n",arr[i] );
	}
	return 0;
}


